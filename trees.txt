[[ch:trees]]
== Chapter: Tree Computations

Trees are a basic structure for representing relations.  It is thus
 natural to ask whether we can perform tree operations in parallel.

As our first motivating example, let's consider the following
question: we are given a binary tree latexmath:[$T$] and asked to
determine the *_in-order rank_* of each node in the tree, defined as
the order of the node in an in-order traversal of the tree.

As two important special cases of this problem, let's consider a
complete binary tree, where each internal node has exactly two
children and a chain, where each internal node has exactly one
child. A complete binary tree is a balanced tree whereas a chain is an
unbalanced tree.

.In-Order Traversal 
====
image:perfect-binary-tree-8.png["An example complete binary tree",width="350pt",align="center"]

An in-order traversal of the complete binary tree above traverses the
nodes in the following order: *a,b,c,d,e,f,g,h,i,j,k,l,m,n,o*.  

====

Let's apply two algorithm design techniques to this problem: divide
and conquer and contraction.

=== Divide and Conquer

For divide and conquer, we can use a two-pass algorithm:

. First pass: compute the size of each subtree in the
tree. 

. Second pass: Compute the in-order ranks by traversing the tree from
root to leaves as we propagate to each subtree in-order rank of its
root, which can be calculated based on the sizes of the left and the
right subtrees.


The first phase of the divide-and-conquer algorithm proceeds by
computing the recursively the sizes of each subtree in parallel, and
the computing the size for the tree by adding the sizes and adding one
for the root. Similarly, the second phase of the algorithm computes
the rank of the root as the size of the left-subtree (assuming we are
counting rank's from zero) plus an offset (initially zero), and
recurses  on the left and the right subtrees.  For the left subtree,
the offset is the same as the offset of the root and for the right
subtree, the offset is the calculated by adding the size of the left
subtree plus one.   


.Two-Pass Algorithm for Computing Ranks
====

image:perfect-binary-tree-8-inorder-ranks.png["Compting ranks",width="400pt",align="center"]

In the example tree above, each node is labeled with the size of its
subtree computed in the first pass and each edge is labeled with the
offset computed in the second pass.  

====


If the tree is balanced, as for example in our example, we can show
that this algorithm performs latexmath:[$O(n)$] work in
latexmath:[$O(\lg{n})$] span.  If however, the tree is not balanced
the algorithm can do poorly, requiring as much as latexmath:[$O(n)$]
span.


.Divide and Conquer on Chains
====
image:chain-9.png["An example chain",width="300pt",align="center"]

An in-order traversal of a chain of nodes yields *a,b,c,d,e,f,g,h,i*
assuming that the left child of each node is "empty." The
divide-and-conquer algorithm would require linear span on this
example.

====

=== Contraction

Appling the idea behind the contraction technique, we want to
"contract" the tree into a smaller tree, solve the problem for the
smaller tree, and "expand" the solution for the smaller tree to
compute the solution for the original tree.

There are several ways to contract a tree.  One way is to "fold" or
"rake" the leaves to generate a smaller tree.  Another way is to
"compress" long branches of the tree removing some of the nodes on
such longe branches. 

==== Rake Operation

Lets define a *_rake_* as an operation that when applied to a leaf
deletes the leaf and stores its size in its parent. With some care, we
can rake all the leaves in parallel: we just need to have a place for
each leaf, sometimes called a *_cluster_*, to store their size at
their parent so that the rakes can be performed in parallel without
interfence.  

Using the rake operation, we can give an algorithm for computing the
in-order traversal of a tree:

. *Base case:*  The tree has only one node, compute the resulty.

. *Contraction step:*  Rake all the leaves to contract the tree.

. *Recursive step:* Solve the problem for the contracted tree.

. *Expansion step:* "Reinsert" the raked leaves to compute the result
for the input tree.


.Contraction with Rake
====

image:perfect-binary-tree-8.png["Computing ranks",width="400pt",align="center"]

Given the example tree above, we rake all the leaves and store their
size in clustered stored in the parents.  For the drawings we draw
the clusters on the edges.

image:perfect-binary-tree-8-rake-1.png["Computing ranks",width="400pt",align="center"]

We can rake the leaves again.

image:perfect-binary-tree-8-rake-2.png["Computing ranks",width="400pt",align="center"]

And again, until we reach a tree with a single node.  We can then
compute the rank of the node as the size of its subtree.

image:perfect-binary-tree-8-rake-3.png["Computing ranks",width="400pt",align="center"]

====

.Expansion with Rake
====

Having reached the base case by contractions, we then perform
expansion steps to compute the result for the original tree.

image:perfect-binary-tree-8-rake-3.png["Computing ranks",width="400pt",align="center"]

As we expand, we compute the in order traversal for the tree
constructed by "expanding" the tree out.
  
image:perfect-binary-tree-8-rake-2-expand.png["Computing ranks",width="400pt",align="center"]

Each expansion corresponds to the a contraction step.

image:perfect-binary-tree-8-rake-1-expand.png["Computing ranks",width="400pt",align="center"]

The expansion step completes when all the contractions are reversed.

image:perfect-binary-tree-8-expand.png["Computing ranks",width="400pt",align="center"]

====

Let's calculate the work and span of this algorithm assuming that we
have a complete binary tree, which is a tree where all internal nodes
have exactly two children and all the leaves are collected at the last
two levels of the tree.  Since a complete binary tree is a full binary
tree, raking all the leaves removes half of the nodes.  Thus we can
write the work recursion as latexmath:[$W(n) = W(n/2) + n$].  This
solves to latexmath:[$W(n) = O(n)$].  Since complete trees are
balanced, for the span we have latexmath:[$S(n) = S(n/2) + \log{n}$].
This solves to latexmath:[$S(n) = O(\lg^2{n})$].



==== Compress Operation

The contraction algorithm based rake operations performs well for
complete binary trees but on unbalanced trees, the algorithm can do
verp poorly. In fact, the contraction algorithm requires
latexmath:[$O(n^2)$] work and latexmath:[$O(n^2)$] span on a chain,
which is a degenerate tree.

Let's consider the worst-case example of the chain and design a
different contraction algorithm that works well just on chains.

Define *_compress_* as an operation that when applied to a node
latexmath:[$u$] with a single child latexmath:[$v$] and parent
latexmath:[$w$] deletes latexmath:[$u$] and the edges incident on it
and inserts an edge from the parent to the child, i.e.,
latexmath:[$(w,v)$].  To incorporate into the computation the
contribution of the compressed vertex, we can construct a *_cluster_*,
which for example, can be attached to the newly inserted edge.  For
the in-order traversal example, this cluster will simply be a weight
corresponding to the size of the deleted nodes.  Initially all edges
have weight latexmath:[$0$].


Using compress operation, we wish to be able to contract a tree to a
smaller tree in parallel. Since a compress operation updates the two
neighbors of a compressed node, we need to be careful about how we
apply these operations.  One way do this is to select in each round an
independent set of nodes (nodes with no edges in between) and compress
them.

Based on this idea, we can give an algorithm for computing the
in-order traversal of a chain:

. *Base case:* The chain consists of a single edge, compute the
result.

. *Contraction step:* Compress an independent set of internal nodes to
obtain a contracted chain.

. *Recursive step:* Solve the problem for the contracted chain.

. *Expansion step:* "Reinsert" the compressed nodes to compute the
result for the input chain.


To maximize the amount of contraction at each contraction step, we
want to select a maximal independent set and do so in parallel.  There
are many ways to do this, we can use a deterministic algorithm, or a
randomized one.  Here, shall use randamization.  The idea is to flip
for each node a coin and select a vertex if it flipped heads and its
child flipped tails. This idea of using randomization to make parallel
decisions is sometimes called *_symmetry breaking_*. 

.Contraction with Compress
====

image:chain-9.png["Computing ranks",width="300pt",align="center"]

In the example chain above, we compress every other internal node to
obtain the new chain below.

image:chain-9-compress-1.png["Computing ranks",width="300pt",align="center"]

We then repeat this process.

image:chain-9-compress-2.png["Computing ranks",width="300pt",align="center"]

And repeat it again until we are down to a single edge at which point
we can solve the problem.

image:chain-9-compress-3.png["Computing ranks",width="300pt",align="center"]

====


.Expansion with Compress
====

Having contracted the chain down to a single edge, we start the
expansion phase, where we "re-insert" the deleted nodes to compute the
result for the expanded tree.

image:chain-9-compress-3.png["Computing ranks",width="300pt",align="center"]

At each expansion step, to compute the result for the re-inserted
nodes, we use the pre-computed result for the clusters adjacent to
them.

image:chain-9-compress-2-expand.png["Computing ranks",width="300pt",align="center"]


image:chain-9-compress-1-expand.png["Computing ranks",width="300pt",align="center"]

Expansion completes when we expand back the input tree. 

image:chain-9-expand.png["Computing ranks",width="300pt",align="center"]

====

Since the algorithm is randomized its analysis requires some care.

For the analysis, we shall make two assumptions:

. all rounds are independent: the source of randomness in each round
is fully independent of the other rounds, and

. coin flips are pairwise independent: the outcome of one coin flip
does not affect that of any other coin flip.

Let latexmath:[$F_i$] be a random variable denoting the fraction of
internal nodes of the chain that are not compressed at round
latexmath:[$i$].  We know that the probability that a node is
compressed is latexmath:[$1/4$].  We thus know that latexmath:[$E
\lbrack F_i \rbrack = m / (m - m/4) = 3/4$] for all latexmath:[$i$].


Let latexmath:[$X_i$] be a random variable denoting the size of the
tree at round latexmath:[$i$].  

We have

[latexmath]
+++++++++++
$$
X_i = n \cdot \Pi_{j=1}^i{F_i}.
$$
+++++++++++

Since all rounds are independent, latexmath:[$F_i$]'s are independent
and thus we can write:

[latexmath]
+++++++++++
$$
E \lbrack X_i \rbrack = n \cdot \Pi_{j=1}^i{E \lbrack F_i \rbrack} =
\frac{3}{4}^i \cdot n.
$$
+++++++++++



Since we perform constant work per node in each round, we can bound
the work as follows.

[latexmath]
+++++++++++
$$
\begin{array}{lll}
W(n) & \le & \sum_{i = 1}^{\infty}{X_i}
\\
E \lbrack W(n) \rbrack & \le & \sum_{i = 1}^{\infty}{\frac{3^i}{4^i} \cdot n}
\\
E \lbrack W(n) \rbrack & \le & O(n).
\end{array}
$$
+++++++++++

Note that for this bound, we made the conservative assumption that the
computation continues infinitely.  This still gives us a tight bound
because we the size of the input decreases geometrically.  We thus
conclude that the algorithm is work efficient.

To bound the span, we need a high-probability bound.  Let's consider
the probability that the number of nodes is non-trivial after
latexmath:[$i = 10 \lg{n}$] rounds.  By Markov's inequality we have


[latexmath]
+++++++++++
$$
\begin{array}{lll}
P \lbrack X_i \ge 1 \rbrack 
& \le & 
E \lbrack X_i \rbrack / 1  =
\\
& \le & 
\frac{3}{4}^{10\lg{n}}
\\
& \le & 
n^{-3}.
\end{array}
$$
+++++++++++

This means that after latexmath:[$10\log{n}$] rounds, the probability
that the tree constains more than a few nodes is tiny.  We can thus
state with high probability that the algorithm terminates after
latexmath:[$O(\log{n})$ rounds. If it does not, we know that we can
always solve the problem using a linear work algorithm.
We can thus write our span bound as follows.


 
[latexmath]
+++++++++++
$$
S(n) = 
\left\{ 
\begin{array}{ll}
R & \mbox{if}~ R \le 10\lg{n}
\\
n & \mbox{otherwise} 
\end{array}
\right.

$$
+++++++++++

By conditioning on a random variable latexmath:[$R$] denoting the
number of rounds we can bound span as follows.

[latexmath]
+++++++++++
$$
\begin{array}{lll}
E \lbrack S(n)] 
& \le & 
E \lbrack S(n) | R \le 10\lg{n} \rbrack  \cdot P  \lbrack  R \le 10\lg{n}  \rbrack  
+
E \lbrack S(n) | R > 10\lg{n} \rbrack  \cdot P  \lbrack  R > 10\lg{n}  \rbrack  
\\
& \le & 
10 \lg{n} \cdot (1-1/n^{3}) 
+ 
n \cdot 1/n^3.
\\
& \le & 
O(\lg{n}).
\end{array}
$$
+++++++++++


//////////////////////////////////////////////////////////////////////

// The method blow is a broken analysis.  It ought to use conditional
// expectations by casing over X_i's.  It does not and ends up being
// sloppy and dangerous.

For instructive purposes we will discuss another method, which we
don't recommend.

Since we know that latexmath:[$F_i = 3/4$] for all latexmath:[$i$] and
since latexmath:[$F_i$] and latexmath:[$X_i$] are independent, we
have:

[latexmath]
+++++++++++
$$
X_{i+1}=  F_i \cdot X_i,~\mbox{and thus}
\\
E \lbrack X_{i+1} \rbrack =  3/4 \cdot X_i \brack.
$$
+++++++++++

Above, we took expectations over only the random choices for a fixed
input size latexmath:[$X_i$].  Since latexmath:[$X_i$] is a random
variable latexmath:[$E[X_{i+1}]$] is itself a random variable, and
thus we can take the expectation over that variable.  

[latexmath]
+++++++++++
$$
E \lbrack E \lbrack X_{i+1} \rbrack  \rbrack  =  3/4 \cdot E \lbrack X_i \rbrack .
\\
E \lbrack X_{i+1} \rbrack  =  3/4 \cdot E \lbrack X_i \rbrack .
$$
+++++++++++

We used here the independence of latexmath:[$F_i$] from
latexmath:[$X_i$] and did so very quietly.  This makes this approach
dangerous.  A sloppy application of this method can lead to
multiplying expectations of dependent random variables.

This yields a recursive equation, which we can solve as latexmath:[$E
\lbrack X_i \rbrack = \frac{3}{4}^i \cdot n $] and thus
latexmath:[$E \lbrack W(n) \rbrack = O(n)$]

//////////////////////////////////////////////////////////////////////



=== Tree Contraction

In this chapter thus far, we have seen that we can compute the
in-order rank a complete binary tree, which is a perfectly balanced
tree, by using a contraction algorithm that rakes the leaves of the
tree until the tree reduces to a single vertex.  We have also seen
that we can compute in-order ranks of nodes in a worst-case unbalanced
tree, a chain, by using a contraction algorithm that compresses nodes
with single child's until the tree reduces to a single edge.

We shall now see that we can in fact compute in-order ranks for any
tree, balanced or unbalanced, by simultaneously applying the same two
operations.

.Algorithm: Tree Contraction
****
[source, {cpp}]
----
tree_contract (T)
if |T| < 1 
  T
else
    TT = rake leaves of T
    TTT = compress and independent set of nodes with a single-child in TT
    tree_contract (TTT)
    expand to TT
    expand to T
----
****  

Since expansion is symmetric to contraction and since we have already
discussed expansion in some detail, in the rest of this chapter, we
shall focus on contraction.

.Tree Contraction 
====
An example tree contraction illustrated on the  input tree below. 

image:unbalanced-binary-tree-6.png["Input tree",width="350pt",align="center"]

image:unbalanced-binary-tree-6-tc-1.png["Tree contraction, round 1",width="350pt",align="center"]

image:unbalanced-binary-tree-6-tc-2.png["Tree contraction, round 2",width="350pt",align="center"]

image:unbalanced-binary-tree-6-tc-3.png["Tree contraction, round 3",width="350pt",align="center"]
====


As in our earlier examples, we can choose the rake and compress
operations to collect information about the tree to compute the
desired property.  For example, we use rake and compress to compute
the in-order rank of the nodes as discussed.  It turns out that rake
and compress are quite flexible and can be used to compute many
different properties.  Another interesting example is expression
trees, where we use a tree to represent a mathematical expression.  To
compute the value of such an expression we can use tree contraction
with rake and compress operations.  As we rake and compress nodes, we
have to be careful about accumulating intermediate values of
expressions so that we can compute in the end the result for the
expression.  To this end, we may use (partially computed) expressions
themselves as clusters.


.Tree Contraction for an expression tree 
====
The expression tree shown below represents  the expression 

[latexmath]
+++++++++++

$$
(1+2) \cdot (3 + 4) 
+ 
\left(
\left( 5 + ( 7 + ( (10 + 11) \cdot 9 ) right) 
\cdot 
6 
\right)
.
$$
+++++++++++

image:unbalanced-expression-tree.png["An expression tree",width="350pt",align="center"]

To compute the value for the expression we first annotate the initial
values for each cluster, which we associate with edges.  Initially all
clusters are identity functions written as latexmath:[$x$].

image:unbalanced-expression-tree-round-0.png["An expression tree",width="350pt",align="center"]

In the first round, we perform a number of rakes and update the
corresponding clusters.  Note that clusters are univariate functions.

image:unbalanced-expression-tree-round-1.png["An expression tree",width="350pt",align="center"]

In the second round, we perform a number of rakes and a compress and
update the corresponding clusters. Note that clusters remain to be
univariate functions. 

image:unbalanced-expression-tree-round-2.png["An expression tree",width="350pt",align="center"]

====





/////
=== Euler Tour Trees

Recall the definiton of <<sec:graph-theory::euler-tours, Euler Tours>>.

A tree latexmath:[$T$] may not be Eulerian.  For example, in a binary tree, the
leaves have degree one.  We can, however, transform a tree to a
directed graph by replacing each (undirected) edge with two edges, one
in each direction. Such a tree corresponds to a graph where each
vertex has even degree (some on in and outgoing edges) and thus is
guarantee to be Eulerian.

INSERT EXAMPLE. 

For the rest of this chapter, we shall consider *_rooted trees_* where
a single vertex is identified as a root.  In rooted trees, edges can
be oriented towards or away from the root.  We shall orient them away
from the root, because this is more consistent with the typical way
trees are represented as a data structure.

The Euler tour of a rooted tree starts at the root, and *_enters_* the
first child, performs an Euler tour of the subtree rooted at the
child, and *_exits_* the child to returt to the root, and enters the
second child and so on.


INSERT EXAMPLE. 

Note that the Euler Tour of a tree is composed of the Euler Tour trees
of the subtrees of the tree.  This makes it possible to perform
certain computations on trees using Euler Tour trees. 

For example, let's suppose that we wish to compute the "sum" of the
elements in a subtree by using a specified associative operation
latexmath:[$\oplus$] with identity latexmath:[$id$]. Suppose
furthermore that we have the inverse for each element under this
operation, such that latexmath:[$x \oplus x^{-1} = id$].  We can use
sequences and scan to perform the computation as follows.

First, we construct the Euler Tour for the tree and represent it as a
sequence.  The sequence contains two entries for each node of the
tree, corresponding to the entry and the ext points.  Now, for the
entry point of each node, we write the label of that node, and we
write latexmath:[$id$] for all the rest of the. We then perform a
sequence scan on this tree with latexmath:[$\oplus$] and
latexmath:[$id$] as our monoid.  We can then compute the sum for any
subtree as taking the result of the scan at the exit point and then
"subtract" the elemen at the entery point, and finally "substract" the
label of the node itself.  

INSERT EXAMPLE


Since sequence scan requires latexmath:[$O(n)$] work in
latexmath:[$O(\lg{n})$] span, this algorithm also has the same work
and span, and this is quite a good parallel algorithm.  The problem is
that it requires an invese operation.  In other words, it does not
suffice to be given a manoid, we actually need a
https://en.wikipedia.org/wiki/Group_(mathematics)[group], which is
algebraic structure that requires an invertibility. 

/////




//////////
Older version
Trees are a basic structure for representing relations.  It is thus
 natural to ask whether we can perform tree operations in parallel.

As our first motivating example, let's consider a very simple
question: we are given a rooted binary tree latexmath:[$T$] and a root latexmath:[$r$] and
asked to determine the number of nodes in the tree.  One way to do
this would be to use divide-and-conquer.  We recursively parallel
compute the size of the left subtree, right subtree, and add one for
the root.  Since the left and the right subtrees are independent, the
computtaions can be don in parallel. If the tree latexmath:[$T$] is balanced, then
such an algorithm performs latexmath:[$Theta(n)$] work in latexmath:[$\Theta(\lg{n})$] span.
If, howener, latexmath:[$T$] is unbalanced, then span can be as large as
$\Omega(n)$.

As our second mativating example, suppose that we are given a rooted
tree latexmath:[$T$] that represents a mathemetical expression consisting of
addition and multiplication operations over real numbers and we wish
to compute the value of this expression.  In such a tree, each
internal node is an operation (plus or multiply) and each leaf is a
real number.  Again, we can solve this problem by using a
divide-and-conquer algorithm, whic computes the values of the
expressions on the left and the right subtrees and combines them
acconding to the operation at the root.  If the tree latexmath:[$T$] is balanced,
then such an algorithm performs latexmath:[$Theta(n)$] work in latexmath:[$\Theta(\lg{n})$
span.  If, however, latexmath:[$T$] is unbalanced, then span can be as large as
linear.


In the rest of this chapter, we discuss two techniques for solving
such problems on trees.  


=== Euler Tour Trees

Recall the definiton of <<sec:graph-theory::euler-tours, Euler Tours>>.

A tree latexmath:[$T$] may not be Eulerian.  For example, in a binary tree, the
leaves have degree one.  We can, however, transform a tree to a
directed graph by replacing each (undirected) edge with two edges, one
in each direction. Such a tree corresponds to a graph where each
vertex has even degree (some on in and outgoing edges) and thus is
guarantee to be Eulerian.

INSERT EXAMPLE. 

For the rest of this chapter, we shall consider *_rooted trees_* where
a single vertex is identified as a root.  In rooted trees, edges can
be oriented towards or away from the root.  We shall orient them away
from the root, because this is more consistent with the typical way
trees are represented as a data structure.

The Euler tour of a rooted tree starts at the root, and *_enters_* the
first child, performs an Euler tour of the subtree rooted at the
child, and *_exits_* the child to returt to the root, and enters the
second child and so on.


INSERT EXAMPLE. 

Note that the Euler Tour of a tree is composed of the Euler Tour trees
of the subtrees of the tree.  This makes it possible to perform
certain computations on trees using Euler Tour trees. 

For example, let's suppose that we wish to compute the "sum" of the
elements in a subtree by using a specified associative operation
latexmath:[$\oplus$] with identity latexmath:[$id$]. Suppose
furthermore that we have the inverse for each element under this
operation, such that latexmath:[$x \oplus x^{-1} = id$].  We can use
sequences and scan to perform the computation as follows.

First, we construct the Euler Tour for the tree and represent it as a
sequence.  The sequence contains two entries for each node of the
tree, corresponding to the entry and the ext points.  Now, for the
entry point of each node, we write the label of that node, and we
write latexmath:[$id$] for all the rest of the. We then perform a
sequence scan on this tree with latexmath:[$\oplus$] and
latexmath:[$id$] as our monoid.  We can then compute the sum for any
subtree as taking the result of the scan at the exit point and then
"subtract" the elemen at the entery point, and finally "substract" the
label of the node itself.  

INSERT EXAMPLE


Since sequence scan requires latexmath:[$O(n)$] work in
latexmath:[$O(\lg{n})$] span, this algorithm also has the same work
and span, and this is quite a good parallel algorithm.  The problem is
that it requires an invese operation.  In other words, it does not
suffice to be given a manoid, we actually need a
https://en.wikipedia.org/wiki/Group_(mathematics)[group], which is
algebraic structure that requires an invertibility. 


/////////

